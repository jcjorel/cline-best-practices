###############################################################################
# IMPORTANT: This header comment is designed for GenAI code review and maintenance
# Any GenAI tool working with this file MUST preserve and update this header
###############################################################################
# [GenAI coding tool directive]
# - Maintain this header with all modifications
# - Update History section with each change
# - Keep only the 4 most recent records in the history section. Sort from newer to older.
# - Preserve Intent, Design, and Constraints sections
# - Use this header as context for code reviews and modifications
# - Ensure all changes align with the design principles
# - Respect system prompt directives at all times
###############################################################################
# [Source file intent]
# Implements the RuleEngine class, which drives the consistency analysis process.
# It retrieves applicable rules from the AnalysisRegistry based on the requested
# analysis type and invokes the corresponding ConsistencyAnalyzer instances to
# apply those rules, collecting any detected inconsistencies.
###############################################################################
# [Source file design principles]
# - Decouples analysis execution logic from specific rules and analyzers.
# - Uses the AnalysisRegistry to discover rules relevant to a given analysis type.
# - Iterates through applicable rules and delegates execution to the registered analyzer.
# - Aggregates inconsistency records generated by the analyzers.
# - Includes error handling for rule application failures.
# - Design Decision: Registry-Driven Rule Execution (2025-04-15)
#   * Rationale: Allows the engine to remain generic while supporting extensible analysis capabilities through registered analyzers and rules.
#   * Alternatives considered: Hardcoding rule execution logic (brittle), Complex event-based system (overkill).
###############################################################################
# [Source file constraints]
# - Depends on `AnalysisRegistry` to provide rules and analyzers.
# - Relies on analyzers correctly implementing the `apply_rule` method.
# - Performance depends on the number of rules and the complexity of the analyzers.
###############################################################################
# [Dependencies]
# codebase:- doc/DESIGN.md
# system:- src/dbp/consistency_analysis/registry.py
# other:- src/dbp/consistency_analysis/analyzer.py
# other:- src/dbp/consistency_analysis/data_models.py
###############################################################################
# [GenAI tool change history]
# 2025-04-15T10:30:15Z : Initial creation of RuleEngine class by CodeAssistant
# * Implemented logic to retrieve and apply rules via the AnalysisRegistry.
###############################################################################

import logging
from typing import Dict, List, Any, Optional

# Assuming necessary imports
try:
    from .registry import AnalysisRegistry, AnalysisError
    from .analyzer import ConsistencyAnalyzer, ConsistencyRule # For type hints
    from .data_models import InconsistencyRecord
except ImportError:
    logging.getLogger(__name__).error("Failed to import dependencies for RuleEngine.", exc_info=True)
    # Placeholders
    AnalysisRegistry = object
    ConsistencyAnalyzer = object
    ConsistencyRule = object
    InconsistencyRecord = object
    AnalysisError = Exception

logger = logging.getLogger(__name__)

class RuleEngine:
    """
    Executes consistency analysis rules by retrieving them from the registry
    and invoking the appropriate analyzers.
    """

    def __init__(self, analysis_registry: AnalysisRegistry, logger_override: Optional[logging.Logger] = None):
        """
        Initializes the RuleEngine.

        Args:
            analysis_registry: The registry containing analyzers and rules.
            logger_override: Optional logger instance.
        """
        if not isinstance(analysis_registry, AnalysisRegistry):
             logger.warning("RuleEngine initialized with potentially incorrect registry type.")
        self.analysis_registry = analysis_registry
        self.logger = logger_override or logger
        self.logger.debug("RuleEngine initialized.")

    def run_analysis(self, analysis_type: str, inputs: Dict[str, Any]) -> List[InconsistencyRecord]:
        """
        Runs all registered consistency rules matching the specified analysis type.

        Args:
            analysis_type: The type of analysis to perform (e.g., "code_doc", "doc_doc", "full_project").
                           Analyzers register their rules under these types.
            inputs: A dictionary containing the necessary input data for the analysis
                    (e.g., {"code_file_path": "...", "doc_file_path": "..."}). The specific
                    keys required depend on the rules being executed for the given type.

        Returns:
            A list of all InconsistencyRecord objects generated by the applied rules.
        """
        self.logger.info(f"Running consistency analysis for type: '{analysis_type}'")
        all_inconsistencies: List[InconsistencyRecord] = []

        try:
            # 1. Get all rules registered for the specified analysis type
            rules_to_run = self.analysis_registry.get_rules_for_analysis_type(analysis_type)
            if not rules_to_run:
                self.logger.warning(f"No consistency rules found for analysis type: '{analysis_type}'")
                return []

            self.logger.info(f"Found {len(rules_to_run)} rules to apply for type '{analysis_type}'.")

            # 2. Iterate through the rules and apply them using their associated analyzer
            for analyzer, rule in rules_to_run:
                if not isinstance(rule, ConsistencyRule) or not isinstance(analyzer, ConsistencyAnalyzer):
                     self.logger.error(f"Invalid rule or analyzer found in registry for type '{analysis_type}'. Skipping.")
                     continue

                self.logger.debug(f"Applying rule '{rule.rule_id}' using analyzer '{type(analyzer).__name__}'...")
                try:
                    # Delegate rule application to the specific analyzer instance
                    rule_inconsistencies = analyzer.apply_rule(rule, inputs)

                    if rule_inconsistencies:
                        self.logger.info(f"Rule '{rule.rule_id}' detected {len(rule_inconsistencies)} inconsistencies.")
                        # Basic validation of results
                        valid_results = [inc for inc in rule_inconsistencies if isinstance(inc, InconsistencyRecord)]
                        if len(valid_results) != len(rule_inconsistencies):
                             self.logger.warning(f"Analyzer '{type(analyzer).__name__}' rule '{rule.rule_id}' returned invalid inconsistency objects.")
                        all_inconsistencies.extend(valid_results)
                    else:
                         self.logger.debug(f"Rule '{rule.rule_id}' found no inconsistencies.")

                except NotImplementedError:
                     self.logger.error(f"Analyzer '{type(analyzer).__name__}' has not implemented apply_rule for rule '{rule.rule_id}'.")
                except Exception as e:
                    self.logger.error(f"Error applying rule '{rule.rule_id}' with analyzer '{type(analyzer).__name__}': {e}", exc_info=True)
                    # Optionally create a generic inconsistency record about the failure?
                    # Or just log and continue? Let's just log for now.

            self.logger.info(f"Consistency analysis type '{analysis_type}' complete. Total inconsistencies found: {len(all_inconsistencies)}")
            return all_inconsistencies

        except AnalysisError as e: # Catch errors from the registry itself
             self.logger.error(f"Error retrieving rules or analyzers from registry: {e}", exc_info=True)
             return [] # Return empty on registry errors
        except Exception as e:
            self.logger.error(f"Unexpected error during rule engine execution for type '{analysis_type}': {e}", exc_info=True)
            return [] # Return empty on unexpected errors
